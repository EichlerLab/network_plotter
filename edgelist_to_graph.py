#!/bin/python
#Author: Anna-Lisa R. Doebley
#        Laboratory of Evan Eichler
#Date: 08/12/2016

#to run this script you need to have the following modules installed and loaded:
#pandas
#numpy
#matplotlib
#networkx
#pygraphviz
#These can all be installed and loaded through anaconda

#Instructions for providing arguments:
#To run this script in command line:
#python path/to/script.py path/to/module_file path/to/edgelist_all path/to/edgelist_within path/to/gene_data path/to/layout_input display_all_edges:<'True'or'False'or'name_of_module'> choose_mods:<'All' or [list,of,mods,to,be,graphed]>

#Example:
#python edgelist_to_graph.py full_mod_list.txt edgelist_all.txt edgelist_within_mods.txt RandomGeneList.1.txt clean_layout.txt True [mod1,mod2,mod4]

#More Information:
#script=path/to/this script
#module_file= csv in the format: gene,module_name
#edgelist_all= (generated by the 'modules_to_edgelist.py' script) tab delimitated csv in the format: gene1	gene2	pearson_correlation_coefficient_r^6
#edgelist_within= (generated by the 'modules_to_edgelist.py' script) tab delimitated csv in the format: gene1	gene2	pearson_correlation_coefficient_r^6
#gene_data = csv in the format: GeneName,Mutation_Score,Number_of_LoF,Number_of_Missense
#layout_input = csv in the format: GeneName,X-coordinate,Y-coordinate 
	#type 'None' to generate a new layout.
	#note: if all the edges between modules are displayed on a graph and a layout is generated for this graph, the modules will be mixed togehter. To generate a layout that is organized by module, put 'False' for the 'display_all_edges' argument. The generated layout will be saved to 'layout_output.txt'. This layout can then be used to display edges between modules without the modules getting mixed together. 
#display_all_edges: True/False/ModuleName ('True' displays all the edges that connect modules to one another. 'False' displays only the edges within modules. typing the name of a module displays all the edges that connect that module to other modules)
#choose_mods: comma separated list of modules to be included on the graph. ex: mod1,mod2,mod4. To include all modules in the module_file type 'All'.

import sys

if len(sys.argv)!=8:
	print "error: 8 arguments required: path/to/script.py path/to/module_file path/to/edgelist_all path/to/edgelist_within path/to/gene_data path/to/layout_input(or type 'None' to generate a layout) display_all_edges:<'True'or'False'or name_of_module(s)> choose_mods:<[list,of,mods,to,be,graphed] or 'All'>"
	print "\n"
	prompts=raw_input("Would you like to use prompts to enter the correct arguments? Y or N?")
	if prompts=='N':
		sys.exit()
	if prompts=='Y':
		module_file=raw_input("Provide path to the module file or type h for more info:")
		if module_file=='h':
			module_file=raw_input("please provide a csv in the format: gene,module_name:")
		edgelist_all=raw_input("Provide path to edgelist_all.txt (This is a csv generated by the 'modules_to_edgelist.py' script):")
		edgelist_within=raw_input("Provide path to edgelist_within.txt (This is a csv generated by the 'modules_to_edgelist.py' script):")
		gene_data=raw_input("please provide a path to the gene and mutation data or type h for more info:")
		if gene_data=='h':
			gene_data=raw_input("please provide a csv in the format: GeneName,Mutation_Score,Number_of_LoF,Number_of_Missense,(more columns are okay as long as the first 4 columns contain the correct information). See RandomGeneList.1 as an example:")
		layout_input=raw_input("please provide a path to the layout file or type 'None' to generate a new layout file (type h for more info):")	
		if layout_input=='h':
			layout_input=raw_input("layout should be a csv in the format: GeneName,X-coordinate,Y-coordinate. See clean_layout.txt for example:")
		display_all_edges=raw_input("Would you like to see edges between modules? Type 'True' to display all edges, 'False' to display only edges within mods or a module name to display only edges connecting to that module:")
		choose_mods=raw_input("List modules that you would like displayed on the graph (ex. mod1,mod2,mod5):")

if len(sys.argv)==8:
	from sys import argv
	script, module_file, edgelist_all, edgelist_within, gene_data, layout_input, display_all_edges, choose_mods = argv

if 'display_all_edges' in display_all_edges:
	sys.exit("'display_all_edges' argument must be 'True' 'False' or [list,of,modules]. Don't include 'display_all_edges' in the argument")
	
if 'choose_mods' in choose_mods:
	sys.exit("'choose_mods' argument must be 'All' or [list,of,mods,to,be,graphed]. Don't include 'choose_mods' in the argument")

if '[All]' in choose_mods:
	sys.exit("Please type 'All' not '[All]' for 'choose_mods' argument")

if 'None' in layout_input:
	if display_all_edges != 'False':
		override=raw_input("With your current options, the generated layout will NOT be organized by module. If you would like a layout organized by module, change 'display_all_edges' to 'False' while generating the layout. Would you like to proceed with current options? Y or N?")
		if override=='N':
			sys.exit()
		elif override!='Y':
			override=raw_input("Error: Invalid option. Would you like to proceed with current options? Please type Y or N")
			if override=='N':
				sys.exit()
			elif override!='Y':
				sys.exit("try again")

import csv
mutation_data=open(gene_data, 'r')
csv_mutation_data=csv.reader(mutation_data, delimiter=",")
for row in csv_mutation_data:
    if " " in row[0]:
    	sys.exit("Error: gene_data must use ',' for the delimiter")

#Import modules that are needed to draw the graph: 
import pandas as pd
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import networkx as nx
import pygraphviz 

#definitions for the graph appearance
def getSize(node, default_size= 300.0):
    if "MutationScore" in node:
        return default_size + ((node["MutationScore"])*60)
    else:
        return default_size

    
def getColor(node):
    if node["MutationScore"] == 0.0:
        return (1,1,1)
    elif node["missense"]== 0.0 and node["LoF"]== 0.0:
    	return (1,1,1)
    elif node["MutationScore"] != 0.0:
        if node["LoF"] > node["missense"]:
            return (1,0,(node["missense"]/node["LoF"])) 
        if node["LoF"] < node["missense"]:
            return (((node["LoF"]/node["missense"])/2+0.5),.5,1)
        if node["LoF"] == node["missense"]:
            return (1,.5,1)
    else:
        return (0,0,0)

#create dictionary with mutationscores for all the modules
MutationScore= {}

mutation_data=open(gene_data, 'r')
csv_mutation_data=csv.reader(mutation_data, delimiter=",")

for row in csv_mutation_data:
    if row[1].startswith ('Total'):
            continue
    MutationScore[row[0]]=float(row[1])

mutation_data.close()

#create a dictionary of the number of loss of function mutations
LoF={}

mutation_data=open(gene_data, 'r')
csv_mutation_data=csv.reader(mutation_data, delimiter=",")

for row in csv_mutation_data:
    if row[2].startswith ('#'):
            continue
    LoF[row[0]]=float(row[2])

mutation_data.close()

#create a dictionary of the number of missense mutations
missense={}

mutation_data=open(gene_data, 'r')
csv_mutation_data=csv.reader(mutation_data, delimiter=",")

for row in csv_mutation_data:
    if row[3].startswith ('#'):
            continue
    missense[row[0]]=float(row[3])

mutation_data.close()

#create dictionary of coexpression values
edgelist=open(edgelist_all, 'r')
csv_edgelist=csv.reader(edgelist, delimiter='\t')

EdgeWeight= {}

for row in csv_edgelist: 
    EdgeWeight[(row[0],row[1])]=8*float(row[2])

edgelist.close()

#make a dictionary of the genes and modules:
mods=open(module_file, 'r')
csv_mods=csv.reader(mods, delimiter=',')

mod_dictionary={}

for row in csv_mods:
	if row[0] == 'Gene':
		continue
	mod_dictionary[row[0]]=row[1]

mods.close()

#create dictionary of edge colors(dark grey for within a module, light grey for between modules)
edgelist=open(edgelist_all, 'r')
csv_edgelist=csv.reader(edgelist, delimiter='\t')

edgelist_within_mod=open(edgelist_within, 'r')
csv_edgelist_within_mod=csv.reader(edgelist_within_mod, delimiter='t')

linecolor= {}

for row in csv_edgelist:
	if mod_dictionary[row[0]] == mod_dictionary[row[1]]:
		linecolor[(row[0],row[1])]=.4,.4,.4
	else:
		linecolor[(row[0],row[1])]=.7,.7,.7	

edgelist.close()
edgelist_within_mod.close()

if display_all_edges=="True":
	selected_edges = pd.read_csv(edgelist_all, sep='\t', header=None, names=['Node1','Node2','Weight'])
elif display_all_edges=="False":
	selected_edges = pd.read_csv(edgelist_within, sep='\t', header=None, names=['Node1','Node2','Weight'])
else:
	edges=[]
	edgelist=open(edgelist_all, 'r')
	csv_edgelist=csv.reader(edgelist, delimiter='\t')
	edgelist_within_mod=open(edgelist_within, 'r')
	csv_edgelist_within_mod=csv.reader(edgelist_within_mod, delimiter='\t')
	for row in csv_edgelist:
	    if mod_dictionary[row[0]] in display_all_edges or mod_dictionary[row[1]] in display_all_edges:
			edges.append(row)
	for row in csv_edgelist_within_mod:
		edges.append(row)
	edgelist.close()
	edgelist_within_mod.close()
	selected_edges = pd.DataFrame(edges, columns=['Node1','Node2','Weight'])

selected_edges_nodes = selected_edges[['Node1', 'Node2']]

ntwk = nx.Graph()
ntwk.add_edges_from([tuple(x) for x in selected_edges_nodes.values])

EdgeWeight_InGraph={}
#For some reason, some of the pairs on the edgelist get flipped when added to ntwk.edges()
#This flips them back in order to pick out the graphed edges from the EdgeWeights. 
reversed_edges=[]
for row in ntwk.edges():
    reversed_edges.append(tuple(reversed(row)))

for k, v in EdgeWeight.items():
    if k in ntwk.edges():
        EdgeWeight_InGraph[k]=v
    elif k in reversed_edges:
        EdgeWeight_InGraph[k]=v

linecolor_InGraph={}

for k, v in linecolor.items():
    if k in ntwk.edges():
        linecolor_InGraph[k]=v
    elif k in reversed_edges:
        linecolor_InGraph[k]=v

edgestyle={}

for k, v in linecolor_InGraph.items():
    #print v
    if v==(.4, .4, .4):
        edgestyle[k]='solid'
    if v==(0.7, 0.7, 0.7):
        edgestyle[k]='dashed'

MutationScore_InGraph={}

for k, v in MutationScore.items():
    if k in ntwk.nodes():
        MutationScore_InGraph[k]=v

LoF_InGraph={}

for k, v in LoF.items():
    if k in ntwk.nodes():
        LoF_InGraph[k]=v

missense_InGraph={}

for k, v in missense.items():
    if k in ntwk.nodes():
        missense_InGraph[k]=v

#set the graph attributes:
nx.set_node_attributes(ntwk, 'MutationScore', MutationScore_InGraph)
nx.set_node_attributes(ntwk, 'LoF', LoF_InGraph)
nx.set_node_attributes(ntwk, 'missense', missense_InGraph)

nx.set_edge_attributes(ntwk, 'edgewidth', EdgeWeight_InGraph)
nx.set_edge_attributes(ntwk, 'edgecolor', linecolor_InGraph)
nx.set_edge_attributes(ntwk, 'edgestyle', edgestyle)

#Apparently there is a bug in networkx 
#which means you have to separately import graphviz_layout in order to use graphviz
from networkx.drawing.nx_agraph import graphviz_layout as gvzl

scale_x=1
scale_y=1
#from Nik's notebook. This makes the figure bigger and removes the background.
finalgraph = plt.figure(frameon=False,figsize=(60*scale_x,60*scale_y))
ax = finalgraph.add_axes([0, 0, 1, 1])
ax.axis('off')


#make a list of all the genes in your modules:
mods=open(module_file, 'r')
csv_mods=csv.reader(mods, delimiter=',')

graphmods=[]

if choose_mods=='All':
	for row in csv_mods:
		if row[0] == 'Gene':
			continue
		graphmods.append(row[0])
else:
	for row in csv_mods:
		if row[0] == 'Gene':
			continue
		if row[1] in choose_mods:
			graphmods.append(row[0])
			
mods.close()

finalgraph=nx.subgraph(ntwk, graphmods)

print "number of nodes:"
print finalgraph.number_of_nodes()
print "number of edges:"
print finalgraph.number_of_edges()

#set the node sizes on the graph
nodesize = [getSize(finalgraph.node[n]) for n in finalgraph.nodes()]
#set the node color on the graph
nodecolor = [getColor(finalgraph.node[n]) for n in finalgraph.nodes()]
#set the line widths
widths = [finalgraph[a][b].get("edgewidth") for a,b in finalgraph.edges()]
#set the line color
colors = [finalgraph[a][b].get("edgecolor") for a,b in finalgraph.edges()]
style = [finalgraph[a][b].get("edgestyle") for a,b in finalgraph.edges()]

if layout_input=='None':
	layout=gvzl(finalgraph, prog='neato')
	layout_output=open('layout_output.txt', 'w')
	csv_layout_output=csv.writer(layout_output, delimiter=',')
	for k, (a,b) in layout.items():
		csv_layout_output.writerow([k,a,b])
	layout_output.close()
else:
	layout={}
	layout_in=open(layout_input, 'r')
	csv_layout_in=csv.reader(layout_in, delimiter=',')
	for row in csv_layout_in:
	    layout[row[0]]=float(row[1]),float(row[2])
	layout_in.close()
	for node in finalgraph.nodes():
		if node in layout:
			continue
		else:
			print 'missing coordinates for:'+node
			sys.exit("Error:layout must have a x,y coordinates for each node.")    
nx.draw_networkx(finalgraph, ax=ax, pos=layout, node_size=nodesize, node_color=nodecolor, style=style, edge_color=colors, width=widths, font_size=18, font_weight="bold")

plt.savefig("graphfigure.png", transparent=True, bbox_inches="tight")

while True:
	
	print "'graphfigure.png' has been saved"
	resize=raw_input("Would you like to resize 'graphfigure.png'(Shrinking the graph will increase the relative size of the nodes while enlarging the graph will decrease the relative size of the nodes)? Y or N?") 
	if resize=='N':
		sys.exit()
	if resize=='Y':
		scale_x=float(raw_input("Enter new size for the x axis:(1 will keep the original length, 2 will double the lengh, 0.5 will cut it in half, etc.)"))
		scale_y=float(raw_input("Enter new size for the y axis:(1 will keep the original length, 2 will double the length, 0.5 will cut it in half, etc.)"))
	elif resize !='Y' and resize !='N':
		resize=raw_input("Please type Y to resize your image or N to quit:")
		if resize !='Y':
			sys.exit()
		if resize=='Y':
			scale_x=float(raw_input("Enter new size for the x axis:(1 will keep the original length, 2 will double the lengh, 0.5 will cut it in half, etc.)"))
			scale_y=float(raw_input("Enter new size for the y axis:(1 will keep the original length, 2 will double the length, 0.5 will cut it in half, etc.)"))
	finalgraph = plt.figure(frameon=False,figsize=(60*scale_x,60*scale_y))
	ax = finalgraph.add_axes([0, 0, 1, 1])
	ax.axis('off')
	finalgraph=nx.subgraph(ntwk, graphmods)
	nx.draw_networkx(finalgraph, ax=ax, pos=layout, node_size=nodesize, node_color=nodecolor, style=style, edge_color=colors, width=widths, font_size=18, font_weight="bold")
	plt.savefig("graphfigure.png", transparent=True, bbox_inches="tight")
